---
theme: seriph
background: white
title: そのJavaScript、V8が泣いてます。V8の気持ちを理解して書くパフォーマンス最適化
info: |
  ## Frontend Conference Tokyo 2025
  そのJavaScript、V8が泣いてます。V8の気持ちを理解して書くパフォーマンス最適化
layout: center
defaults:
  layout: center
drawings:
  persist: false
transition: slide-left
mdc: true
seoMeta:
  ogImage: auto
css: unocss
highlighter: shiki
---

<style>
@import './style.css';
</style>

# そのJavaScript、V8が泣いてます。<br/> V8の気持ちを理解して書くパフォーマンス最適化

<!--
皆さん、こんにちは！本日は「そのJavaScript、V8が泣いてます。V8の気持ちを理解して書くパフォーマンス最適化」というテーマでお話しします。

皆さんが毎日書いているJavaScript、その裏側で一体何が起きているのか、考えたことはありますか？
今日は、ChromeやNode.jsの心臓部であるV8エンジンの気持ちを少しだけ覗き見て、どうすればV8に好かれる、つまりパフォーマンスの高いコードが書けるようになるのか、そのヒントを共有したいと思います。
-->

---

<div class="grid grid-cols-2 gap-4 items-center">
<div>

## 自己紹介

- 名前：西 悠太
- 所属：株式会社ダイニー
- TypeScriptが好きです

</div>
<div>

<img src="/icon.png" alt="プロフィール画像" class="rounded-full w-48 h-48" />

</div>
</div>

<!--
改めまして、西 悠太と申します。株式会社ダイニーでPlatform Engineerとして働いています。TypeScriptが大好きで、日々どうすればもっと良いコードが書けるか考えています。本日はどうぞよろしくお願いします。
-->

---

## V8とは？

**V8**は、Googleが開発するオープンソースのJavaScriptおよびWebAssemblyエンジンです。現代のウェブとサーバーサイドアプリケーションの根幹を支える技術と言えます。

**主な使用例**:

- **Google Chrome**: 実行エンジンとしてV8を採用
- **Node.js**: V8をベースにしたJavaScript実行環境
- **Electron**: VS Code, Slack, Discordなど、数多くのデスクトップアプリケーションが内部でV8を利用

私たちが書くJavaScriptコードのパフォーマンスは、このV8の働きに直接的に依存するため、その内部構造を理解することは、より高速なアプリケーションを開発する上で極めて重要です。

<!--
まず初めに、「V8」とは何かを簡単におさらいしましょう。
V8はGoogleが開発したJavaScriptエンジンです。皆さんが使っているGoogle Chromeはもちろん、Node.jsや、VS Code、SlackといったElectron製のデスクトップアプリの裏側でも動いています。

つまり、私たちが書くJavaScriptのパフォーマンスは、このV8の働きに完全に依存していると言っても過言ではありません。V8の仕組みを理解することは、高速なアプリケーション開発への一番の近道です。
-->

---

## V8コンパイラの全体像

V8は「**起動速度**」と「**実行速度**」という相反する要求を両立させるため、複数のコンパイラを使い分ける**段階的最適化**戦略を採用しています。

全てのコードを一度に最高レベルで最適化するのではなく、コードの実行頻度、いわゆる「温度」に応じて、より高度なコンパイラへと処理を引き継いでいきます。

| 層       | コンパイラ                           | 役割                       |
| :------- | :----------------------------------- | :------------------------- |
| **Tier 0** | **Ignition** (インタープリタ)          | 即時実行 & プロファイル収集  |
| **Tier 1** | **Sparkplug** (ベースライン)         | 高速な非最適化コンパイル     |
| **Tier 2** | **Maglev** (中間最適化)              | バランスの取れた高速最適化   |
| **Tier 3** | **TurboFan** (最適化)                | 最高レベルのパフォーマンス   |

<!--
V8は非常に賢く、「全部を全力で最適化する」ような非効率なことはしません。
「**起動速度**」と「**実行速度**」という、相反する要求を満たすために、複数のコンパイラを使い分ける**段階的最適化**という戦略をとっています。

コードの実行頻度、いわゆる「温度」に応じて、より高度なコンパイラに処理を引き継いでいきます。
まずはインタプリタである **Ignition** がすぐに実行を開始し、コードが温まってきたら **Sparkplug** や **Maglev** が素早くコンパイル、そして本当に「熱い」コードだけを、最高性能の **TurboFan** が徹底的に最適化します。
-->

---

# すべての最適化の基礎: Ignition

<!--
この多層構造の土台となるのが、最初のコンパイラ、**Ignition** です。
-->

---

## Ignitionの役割

**Ignition**は、V8のインタープリタです。JavaScriptコードを受け取り、可能な限り速く実行を開始します。

これを実現するために、JavaScriptのソースコードをマシンが直接実行するマシン語ではなく、**バイトコード**と呼ばれる中間表現に変換します。<br/>このバイトコードは、Ignitionが内蔵する**レジスタベース**の仮想マシンによって解釈・実行されます。

<!--
Ignitionはインタプリタです。その最大の使命は、JavaScriptコードを受け取って、**とにかく速く実行を開始する**こと。
そのために、ソースコードをマシン語ではなく、**バイトコード**という中間表現に変換します。このバイトコードをIgnitionが解釈しながら実行することで、重いコンパイル作業を待つことなく、すぐにコードが動き出すのです。このとき、Ignitionはレジスタベースの仮想マシンとして動作します。
-->

---

## Ignitionの最重要任務

Ignitionは単にコードを実行するだけではありません。<br/>後の最適化コンパイラが最高のパフォーマンスを引き出すための**偵察**として、実行時のコードの振る舞いを詳細に記録します。

このプロファイル情報は **Feedback Vector** と呼ばれ、以下のような情報を含みます。

- **型情報**: 関数に渡された引数や、変数に代入された値がどのような型（数値、文字列、オブジェクトなど）であったか
- **オブジェクト形状**: オブジェクトがどのようなプロパティを、どのような順序で持っていたか（**Hidden Class**）
- **実行回数**: 関数が何回呼び出されたか、ループが何回繰り返されたか

<!--
しかし、Ignitionの仕事はそれだけではありません。もっと重要な任務があります。
それは、後の最適化コンパイラのための**偵察**です。コードを実行しながら、その振る舞いを詳細に記録します。

この記録は **Feedback Vector** と呼ばれ、「この関数にはどんな型の引数が渡されたか」「オブジェクトはどんな形をしていたか」「このループは何回実行されたか」といった貴重な情報が詰まっています。この情報こそが、後の高度な最適化のすべての鍵を握ります。
-->

---

## Ignitionのキーテクノロジー①：Hidden Class

Hidden Class（V8内部名: Map）は、V8がオブジェクトの内部構造（shape）を管理する仕組みです。<br/>（一般的な文献では「shape」と表現されることもあります）

JavaScriptのオブジェクトは動的にプロパティを追加できますが、V8はプロパティの **「名前と追加順序」**（および属性/アクセサの種別）が同じオブジェクトを「同じ形状」とみなし、内部的に同じ Map を割り当てます。

この仕組みにより、V8はプロパティの格納場所（in-object かプロパティ配列か、そのオフセット）を素早く特定できます。<br/>オブジェクト生成後にプロパティを追加しても、全インスタンスが“同じ順序・同じ有無”で追加される限りは、同じ Map の遷移チェーンを辿るため最適化は維持されます。問題になるのは、インスタンスごとに追加順序や有無が揺れる場合や、`delete` などで形状を壊して辞書モードへ移行する場合で、こうした不安定さが IC を多相化させ、最適化効率を下げます。

<!--
Ignitionが集める情報の中でも特に重要なのが **Hidden Class（V8内部名: Map）** です。（一般的な文献では「shape」と表現されることもあります）
JavaScriptのオブジェクトは動的ですが、V8は「プロパティの名前と順番が同じオブジェクト」は「同じ形状」とみなし、内部的に同じHidden Classを割り当てます。

これによって、V8はプロパティがメモリのどこにあるかを瞬時に特定できます。
生成後にプロパティを追加しても、全インスタンスで同一の順序・同一の有無で遷移していれば最適化は維持されます。問題は、インスタンスごとに追加順序や有無が揺れる場合や、`delete` などで形状を壊して辞書モードへ移行する場合で、こうした不安定さがICを多相化させ、最適化効率を下げます。
-->

---

## Ignitionのキーテクノロジー②：Elements Kind

Hidden Classがオブジェクトの形状を扱うのに対し、Elements Kindは配列の要素を効率的に扱うための仕組みです。V8は配列の中身に応じて、内部的な表現方法（Elements Kind）を動的に最適化します。

**主な種類と速度順**:

1. `PACKED_SMI_ELEMENTS`: 隙間なく、小さな整数(SMI)のみが格納されている状態
2. `PACKED_DOUBLE_ELEMENTS`: 浮動小数点数が含まれる状態
3. `PACKED_ELEMENTS`: 任意のJS値が格納される状態（数値は `HeapNumber` として格納）

**PACKED (密) vs HOLEY (疎)**:

- `[1, 2, 3]` のような隙間のない配列は **PACKED** となり高速です
- `[1, , 3]` のように要素が抜けている配列は **HOLEY** となり低速になります
補足: `arr[1] = undefined` は“穴”ではありません。`delete arr[1]`、離れたインデックスへの代入（例: `arr[9] = 1`）、`length` の先行拡張などが“穴”を作ります。

V8は可能な限り特化度の高い Elements Kind を維持しようとしますが、型の異なる要素が追加されると、より一般的な種類へと基本的に一方向の遷移（降格）が発生します<br/>（同じ配列は原則戻りません。新しい配列を生成すれば `PACKED` にできます）。

<!--
オブジェクトの形状がHidden Classなら、配列の中身を管理するのが **Elements Kind** です。
V8は配列の中身を見て、内部的な表現方法を最適化します。

例えば、小さな整数だけの配列は非常に高速な`PACKED_SMI_ELEMENTS`として扱われます。
しかし、そこに浮動小数点数が1つでも入ると、少し遅い`PACKED_DOUBLE_ELEMENTS`に格下げされます。
さらに、もし配列に穴、つまり `[1, , 3]` のような空き要素があると、`HOLEY`というさらに遅い種類になってしまいます。
この降格は同じ配列インスタンスでは戻れません（新しい配列を作れば PACKED にできます）。
なお、2025年時点では `Array.prototype.fill` に限り、穴埋め時に `HOLEY` から `PACKED` へ戻す最適化が入った環境があります。
-->

---

## Ignitionのキーテクノロジー③：Inline Cache (IC)

**Inline Cache (IC)** は、Hidden Classを利用してプロパティアクセスを劇的に高速化するキャッシュ機構です。

**仕組み**: 初回アクセス時に、オブジェクトのHidden Classとプロパティのメモリ上の位置（オフセット）をセットでキャッシュします。2回目以降は、同じHidden Classであれば検索をスキップし、直接オフセットを参照します。

**状態**:

- **Monomorphic (単一形状)**: 最も理想的で最速
- **Polymorphic (多形状)**: 2〜4種類の形状を扱う。少し遅くなる
- **Megamorphic (超多形状)**: 5種類以上の形状を扱う。ICによる最適化を諦め、大幅に低速化する

<!--
そして、Hidden Classを活かして爆速化を実現するのが **Inline Cache (IC)** です。
初めて `user.name` のようなプロパティにアクセスする時、V8は「このHidden Classなら、nameプロパティはメモリのこの場所にある」という情報をキャッシュします。
2回目以降、同じHidden Classのオブジェクトが来たら、検索をスキップして直接メモリを読みに行きます。これが **Monomorphic** という最速の状態です。

もし、いくつかの異なる形状のオブジェクトが来るようだと **Polymorphic** になり、少し遅くなります。
そして、あまりに多くの形状が来ると **Megamorphic** となり、V8は最適化を諦めてしまい、パフォーマンスは大きく低下します。
-->

---

# 常識を覆した超高速コンパイラ: Sparkplug

<!--
さて、Ignitionからバトンを受け取るのが、次のコンパイラ **Sparkplug** です。
-->

---

## Sparkplugの設計思想

**Sparkplug**は、V8 v9.1で導入された**非最適化**（ベースライン）コンパイラです。その核心的な思想は、従来のコンパイラの常識を完全に無視することにあります。

通常のコンパイラはソースコードをAST（抽象構文木）やIR（中間表現）に変換し、それを最適化してからマシン語を生成します。しかしSparkplugは、**Ignitionが生成したバイトコードから直接マシンコードを生成**することで、これらのプロセスを全て省略し、驚異的なコンパイル速度を実現します。
補足: SparkplugはIRを生成せず、最適化は基本的に行いません（ごく局所的なピープホール最適化程度）。

<!--
Sparkplugは、V8の歴史の中でも特にユニークなコンパイラです。
その思想は、「**最適化をしない**」。従来の常識を完全に無視しています。
通常のコンパイラが行うASTの構築や中間表現への変換といった複雑なプロセスをすべて省略し、Ignitionが生成した**バイトコードから直接マシンコードを生成**します。これにより、驚異的なコンパイル速度を実現しています。
-->

---

## Sparkplugの内部実装と利点

Sparkplugの実装は、コンパイラ全体が実質的に巨大な**switch文**を含む単一のループとして構成されています。各バイトコード命令に対し、事前に用意された固定のマシンコード生成関数を呼び出すだけ、という極めてシンプルな構造です。

このアプローチが効果的なのは、**多くのJavaScriptコードは数回しか実行されない**という現実があるためです。複雑な最適化にかける時間が、それによって得られる実行時間の短縮を上回ることが多いため、Sparkplugは「変換による高速化」以外の最適化を大胆に切り捨てています。
技術的には、ループ検出のための軽い前処理パスを経てからコード生成する実装（2パス）だった時期もありますが、本質はバイトコードの線形走査による直接コード生成です。
実行速度向上の主因は、インタプリタ特有のオペランドのデコードや次バイトコードへのディスパッチといったオーバーヘッドを、事前に機械語へ前取りすることで取り除ける点にあります。
また、Sparkplugはインタプリタ互換のスタックフレームを維持し、多くの処理を builtins に委譲するため、デバッガ/プロファイラ/例外スタック/OSR（最適化・脱最適化）の連携が容易です。

<!--
なぜこんなアプローチが有効なのでしょうか？
それは、**多くのJavaScriptコードは数回しか実行されない**という現実があるからです。
複雑な最適化に時間をかけるより、多少非効率でもいいから、とにかく速くネイティブコードに変換してしまった方が、トータルでは速い、という判断です。
Sparkplugは、この「変換するだけ」という割り切りによって、インタプリタと最適化コンパイラの間のギャップを埋める重要な役割を担っています。
実装上は、バイトコードを線形に走査する巨大なswitchループで、各命令に対応した固定のコード生成ルーチンを呼び出します。
また、インタプリタ互換のスタックフレームを維持し、多くの処理をbuiltinsに委譲するため、デバッガ/プロファイラ/例外スタック/OSR（最適化・脱最適化）との連携が容易です。
-->

---

# バランス型の現実的な最適化: Maglev

<!--
次に登場するのが、バランス型の最適化コンパイラ **Maglev** です。
-->

---

## Maglevの設計思想：「十分に良いコードを、十分に速く」

**Maglev**は、SparkplugとTurboFanの間を埋める、高速な**中間最適化**コンパイラです。

Maglevは、Ignitionが収集した**Feedback Vectorを初めて本格的に活用**し、低コストで効果の高い最適化を実施します。

<!--
Maglevの役割は、Sparkplugと、後述する最高峰のTurboFanとの間を埋めることです。
その思想は「**十分に良いコードを、十分に速く生成する**」。
ここで初めて、Ignitionが収集した **Feedback Vector** が本格的に活用されます。時間をかけすぎず、それでいて効果の高い、コストパフォーマンスに優れた最適化を行います。
-->

---

## Maglevの主要技術①：SSAと制御フローグラフ

**SSA (静的単一代入) 形式**:
MaglevはIRとしてSSA形式を採用しています。この形式では各変数が一度だけ代入されるため、データフローの解析が劇的に簡単になり、定数伝播や不要コード削除といった基本的な最適化が、複雑な解析なしに実現できます。

**制御フローグラフ (CFG)**:
コードの実行経路（ループや条件分岐）をグラフとして構築することで、基本的な最適化（例: 定数伝播や不要コード削除）を低コストで適用しやすくします。コンパイル時間を抑えるため、高度なループ変換は目的外です。

<!--
Maglevは、SSA形式という中間表現を採用しています。これにより、データの流れが追いやすくなり、定数伝播や不要コード削除といった基本的な最適化を効率的に行うことができます。
また、コードの実行経路をグラフとして解析することで、ループ内の無駄な処理を外に出す、といった最適化も行います。
-->

---

## Maglevの主要技術②：型フィードバックと表現選択

**型フィードバックによる最適化**:
Ignitionが収集した型情報を活用し、オブジェクトの形状(Hidden Class/Map)が安定しているプロパティアクセスに対しては、形状チェック（例: CheckMap）とオフセット読み取り（例: LoadField）に特化した効率的なコードを生成します。

**表現選択（Representation Selection）**:
数値などの値について最適な内部表現（例: Smi/整数、浮動小数点、タグ付き/非タグ値）を選び、必要に応じてアンボックス/リボックスを行うことで、演算やレジスタ渡しを高速化します。

<!--
Maglevの強みは、Ignitionからの**型フィードバック**を本格活用することにあります。
形状が安定しているプロパティアクセスには、形状チェック（例: CheckMap）とオフセット読み取り（例: LoadField）に特化したコードを生成します。
さらに、数値などの **表現選択（Representation Selection）** を行い、必要に応じてアンボックス/リボックスして演算やレジスタ渡しを高速化します。
やりすぎない範囲で、コスト対効果の高い最適化を素早く適用するのがMaglevです。
-->

---

# 最高峰の最適化コンパイラ: TurboFan

<!--
そしてついに、V8の最終兵器、**TurboFan** の登場です。
-->

---

## TurboFanの役割

**TurboFan**は、V8で最も高度な最適化を担当するコンパイラです。主に実行頻度が高い「ホット」な関数に適用されます。近年は **Profile-Guided Tiering** により、特性に応じて早期にTurboFanへ直接昇格させるケースもあります。

<!--
TurboFanは、V8で最も高度な最適化を行うコンパイラです。
実行頻度が極めて高い「ホット」な関数にのみ、満を持して適用されます。
コンパイルに時間はかかりますが、それに見合うだけの最高レベルのパフォーマンスを引き出すことがその役割です。
-->

---

## TurboFanのコア技術①：中間表現(IR)アーキテクチャ

TurboFanは、最高レベルの最適化を実現するために、歴史的な **Sea-of-Nodes** と、近年本流になりつつある **Turboshaft** の2系統のIRを背景に持ちます。

**Sea-of-Nodes** は、データフローと制御フローを単一のグラフで表現するIRです。この構造は、命令の並べ替えに最大限の柔軟性をもたらし、強力な大域的最適化を可能にしますが、その複雑さからコンパイル時間が長くなるという性質がありました。

それに対し **Turboshaft** は、より伝統的な制御フローグラフ(CFG)をベースにしたIRです。最初にコードの実行経路を固定し、そのブロック内で最適化を行うため、コンパイルのオーバーヘッドが大幅に削減されます。V8は、JavaScriptの動的な性質上、Sea-of-Nodesの理論的な利点が常に活かせるとは限らないという経験則から、より実用的で高速なTurboshaftへの移行を進めています。現在、Wasmは大部分がTurboshaft化済みで、JavaScript側もLoweringや最適化の多くが段階的にTurboshaftへ移行しています。

<!--
TurboFanがなぜ強力かというと、その心臓部である中間表現が非常に優れているからです。
歴史的には **Sea-of-Nodes** という非常に柔軟で強力なIRが使われてきましたが、これは複雑でコンパイルに時間がかかるという側面もありました。
そのため、現在ではより高速で実用的な **Turboshaft** という新しいIRへの移行が進んでいます。これは、JavaScriptという動的な言語の性質を踏まえた、V8の長年の経験の結晶と言えます。
-->

---

## TurboFanのコア技術②：投機的最適化と脱最適化

**投機的最適化**は、TurboFanの真骨頂です。Feedback Vectorに基づき、「この変数は常に数値である」「この条件分岐は常にtrueである」といった **予測（賭け）** を行います。

この予測が的中している限り、型チェックなどを省略した非常に高速なコードが実行されます。もし予測が外れた場合、**脱最適化 (Deoptimization)** という安全装置が作動し、実行中のコードを即座に安全な下位のコンパイラのコードに戻します。これにより、安全性を担保しつつ、動的言語であるJavaScriptで静的言語並みの最適化を可能にしています。

<!--
TurboFanの真骨頂、それが **投機的最適化** です。
これは、Feedback Vectorを元に、「この変数はきっと次も数値だろう」「この分岐はきっとtrueだろう」といった**予測（賭け）** を行う最適化です。

この「賭け」が当たっている間は、型チェックなどをすべて省略した、静的言語並みの超高速なコードが実行されます。
もし予測が外れたら、**脱最適化 (Deoptimization)** という安全装置が作動し、実行を即座に安全な下位のコード（Maglevなど）に戻します。
この仕組みにより、安全性を担保しつつ、大胆な最適化を可能にしているのです。
-->

---

## TurboFanの高度な最適化技術

TurboFanは、前述のコア技術を基盤に、多数の高度な最適化技術を駆使します。

**グローバル値番号付け (GVN)**: プログラム全体で冗長な計算を検出し、削除します。

**数値範囲解析**: 数値の取り得る範囲を解析し、分岐や境界チェックを削減します。

**強度低減**: 除算を乗算に、乗算をシフト演算に置き換えるなど、高コストな演算を低コストなものに変換します。

**エスケープ解析**: オブジェクトの逃避性に基づき、割り当てのスタック化や割り当て自体の削除を行います。

**高度なループ最適化**: ループ不変式の移動、ループ融合など。JS一般の自動ベクトル化は限定的で、主にWasm/一部の組み込みで有効です。

<!--
TurboFanは、投機的最適化を基盤に、コンパイラ理論の粋を集めたような多数の高度な最適化技術を駆使します。
プログラム全体で重複する計算を削除したり、コストの高い演算を安い演算に置き換えたり、ループ処理を徹底的に効率化したりします。
これにより、特に数値計算を多用するような処理で劇的な性能向上を実現します。
-->

---

## TurboFanの脱最適化の限界

TurboFanには重要な安全装置があります：同じ関数で脱最適化が多発すると、実装依存のヒューリスティックにより再最適化が抑制・遅延される場合があります（閾値や挙動はV8のバージョンやフラグで変動します）。

これは最適化と脱最適化の無限ループを防ぐための機構で、型が頻繁に変わるコードでは最適化されない状態が続き得ます。

<!--
ただし、TurboFanには重要なルールがあります。**同じ関数で脱最適化が一定回数（実装依存）発生すると、その関数の再最適化が抑制**されます。これは、最適化と脱最適化の無限ループを防ぐための安全装置です。つまり、型が頻繁に変わる予測不能なコードは、最終的に最適化されないまま実行され続けることがあります。
-->

---

## 2024年の新技術: Profile-Guided Tiering

IntelとGoogle V8チームが共同開発した**Profile-Guided Tiering**は、関数ごとに最適なコンパイラ戦略を選択します。

- 頻繁に使用される関数は早期にTurboFanへ直接昇格
- 脱最適化が多い関数は遅延ティアリング戦略を適用
- **Speedometer 3で約5%の性能向上**を実現（Intel Core Ultra Series 2）

<!--
V8の進化は止まりません。2024年には、Intelと共同で **Profile-Guided Tiering** という新技術が導入されました。
これは、これまでのプロファイル情報をさらに活用し、「この関数はすぐに熱くなるから、最初からTurboFanに送ろう」とか、「この関数は脱最適化が多いから、しばらく様子を見よう」といった、より賢いコンパイラのスケジューリングを行います。
この改善だけで、環境（CPU/ブラウザの組み合わせ）に依存しますが、Speedometer 3 で約5%の性能向上が報告されています。
-->

---

# V8に好かれるコードの書き方

<!--
さて、ここまでV8の内部構造を駆け足で見てきました。
この知識を元に、明日から私たちが実践できる「V8に好かれるコードの書き方」を5つのポイントに絞ってご紹介します。
-->

---

## 1: オブジェクトの形状を保持する

**なぜ重要か？**: オブジェクトの形状(Hidden Class/Map)が安定していると、**Inline Cache(IC)** が有効に機能し、プロパティアクセスが高速化されます。生成後にプロパティを追加しても、全インスタンスで“同じ順序・同じ有無”なら同じMap遷移を辿れるため最適化は維持されます。問題は、インスタンスごとに追加順序や有無が揺れる、`delete` が混じる等で形状が不安定になる場合で、ICが多相化して性能が低下し、場合によっては辞書モードへ移行します。

<!--
1つ目は、**オブジェクトの形状を保持すること**です。
先ほど説明した通り、安定した形状は **Inline Cache** が有効に働くための絶対条件です。
-->

---

## ❌ Before: 形状が変化するコード

このコードでは、`user` は生成後に段階的にプロパティを追加しています。
遷移自体は正常ですが、実運用でインスタンスごとに追加順序や有無が揺れるとICが多相化しやすく、最適化効率が落ちます。

```javascript
const user = { id: 1 };
user.name = "Taro";
user.isAdmin = false;
```

<!--
このコードを見てください。オブジェクトを生成した後に、プロパティを次々と追加しています。
このパターンは、インスタンス間で順序や有無が揺れやすく、ICが多相化しやすい点が問題です。全インスタンスで同一順序・同一有無なら影響は小さいですが、現場では揺れが入りがちです。
-->

---

## ✅ After: 形状が安定したコード

こちらのコードでは、`User` インスタンスは常に同じ形状を持つため、V8は安心して最適化できます。

```javascript
class User {
  constructor(id, name) {
    this.id = id;
    this.name = name;
    this.isAdmin = false;
  }
}

const user1 = new User(1, "Taro");
const user2 = new User(2, "Jiro");
```

<!--
理想的なのはこちらです。
クラスを使うか、あるいはオブジェクトリテラルで全てのプロパティを最初に定義します。
こうすれば、`User`インスタンスは常に同じ形状を持つため、Inline CacheがMonomorphicな状態を維持でき、プロパティアクセスが非常に高速になります。
-->

---

## 2: 型の一貫性を維持する

**なぜ重要か？**: 変数や引数の型が安定していると、TurboFanの**投機的最適化**が成功しやすくなります。V8は「この関数はきっと次も同じ型で呼ばれるだろう」と予測して最適化するため、その予測を裏切らないことが重要です。

<!--
2つ目のポイントは、**型の一貫性を維持すること**です。
これは、TurboFanの**投機的最適化**を成功させるための鍵です。V8の「この変数はきっと次も同じ型だろう」という予測を裏切らないことが重要です。
-->

---

## ❌ Before: 型が不安定なコード

このコードでは、`add` 関数に数値と文字列という異なる型が渡されています。これにより、V8のInline CacheはPolymorphicまたはMegamorphicな状態に陥り、型を毎回チェックする必要が生まれるため、最適化の効率が著しく低下します。

```javascript
function add(a, b) {
  return a + b;
}

add(1, 2);
add("a", "b");
```

<!--
この`add`関数は、数値と文字列の両方を受け取っています。
これにより、V8は毎回「今回はどっちの型だ？」とチェックする必要があり、型に特化した最適化を行うことができません。
-->

---

## ✅ After: 型が一貫したコード

こちらのコードでは、関数を数値用と文字列用に分離しています。これにより、各関数は常に同じ型（Monomorphic）の引数を受け取るため、V8は安心して型に特化した最適化を行うことができます。

```javascript
function addInt(a, b) {
  return a + b;
}

function concatStr(a, b) {
  return a + b;
}

addInt(1, 2);
concatStr("a", "b");
```

<!--
このように、責務に応じて関数を分離しましょう。
`addInt`は常に数値を受け取り、`concatStr`は常に文字列を受け取ります。
これにより、各関数は常にMonomorphicな状態となり、V8は安心して型に特化した最高の最適化コードを生成できます。
-->

---

## 3: 例外による脱最適化を避ける

**なぜ重要か？**:
歴史的に、古いV8では `try...catch` があるだけで最適化が阻害されましたが、現代のV8 (TurboFan) ではこの挙動は改善されています。`try...catch` ブロックの**存在自体**は、もはや最適化の妨げにはなりません。

しかし、重要なのは、**実際に例外がスローされ `catch` される**と、それが「予測不能な事態」と見なされ、高確率で**脱最適化**（低速なコードへのフォールバック）を引き起こすという点です。

ループ内など「ホット」な箇所で脱最適化が頻発すると、V8はその関数の最適化を最終的に諦めてしまう可能性があります。

<!--
3つ目は、**例外による脱最適化を避けること**です。
重要なのは、`try...catch`ブロックの**存在自体**は、もはや最適化を阻害しないということです。
問題は、**実際に例外がスローされ、`catch`される**ことです。これはV8にとって「予測不能な事態」であり、高確率で**脱最適化**を引き起こします。
-->

---

## ❌ Before: 例外に頼った処理

ループ内でプロパティが存在しない可能性を `try...catch` で処理すると、`catch` に入るたびに脱最適化が起きるリスクがあります。

```javascript
function getNames(users) {
  const names = [];
  for (const user of users) {
    try {
      // user.profile が無い場合に TypeError が発生
      names.push(user.profile.name);
    } catch (e) {
      names.push('Unnamed');
    }
  }
  return names;
}
```

<!--
このように、ループの中でプロパティが存在しないかもしれない、という予測可能なエラー処理を`try...catch`で行うのはアンチパターンです。
`catch`ブロックが実行されるたびに、脱最適化が起きるリスクがあり、パフォーマンスが大きく損なわれます。
-->

---

## ✅ After: 事前チェックによる安定した処理

`try...catch` を使わず、プロパティの存在を事前にチェックすることで、例外の発生と脱最適化のコストを完全に回避します。

```javascript
function getNames(users) {
  const names = [];
  for (const user of users) {
    const name = user.profile?.name ?? 'Unnamed';
    names.push(name);
  }
  return names;
}
```

<!--
代わりに、このようにプロパティの存在を事前にチェックしましょう。
このコードはV8にとって完全に予測可能です。例外の発生も、それに伴う脱最適化のコストもありません。これが安定して高速なコードです。
-->

---

## 4: インライン化されやすい関数を心がける

**なぜ重要か？**:
V8は、小さな関数を呼び出し元に埋め込む**インライン化**で、関数呼び出しのコストを削減します。しかし、その判断は「何行以内」といった単純なものではありません。V8は関数のサイズ、呼び出し頻度、型の安定性などを総合的に評価し、インライン化の可否を判断します。V8にとって判断が難しい、大きすぎる・複雑すぎる関数はインライン化が見送られ、パフォーマンス向上の機会を逃してしまいます。

<!--
4つ目のポイントは、**インライン化されやすい関数を心がけること**です。
V8は小さな関数を呼び出し元に埋め込むことで、関数呼び出しのコストを削減します。
-->

---

## ❌ Before: 大きく、複数の責任を持つ関数

データ加工、検証、整形といった複数の役割を担っており、V8にとってインライン化の判断が難しい状態です。

```javascript
function processUser(user) {
  const fullName = `${user.lastName} ${user.firstName}`;
  if (fullName.length > 20) {
    console.error('Name is too long');
    return null;
  }
  return { id: user.id, fullName };
}
```

<!--
この`processUser`関数は、名前の加工、検証、整形と、複数の役割を一つの関数で担っています。
このような大きくて複雑な関数は、V8がインライン化すべきかどうか判断しにくく、最適化の機会を逃しがちです。
-->

---

## ✅ After: 小さく、単一責任の関数に分割

役割ごとに小さな関数に分割することで、各関数はV8にインライン化されやすくなります。特に `getFullName` のような小さく純粋な関数は、インライン化の最有力候補です。

```javascript
function getFullName(user) {
  return `${user.lastName} ${user.firstName}`;
}

function validateName(name) {
  return name.length <= 20;
}

function processUser(user) {
  const fullName = getFullName(user);
  if (!validateName(fullName)) {
    console.error('Name is too long');
    return null;
  }
  return { id: user.id, fullName };
}
```

<!--
このように、役割ごとに小さな関数に分割しましょう。
`getFullName`のような、小さく純粋な関数は、V8にとってインライン化の最有力候補です。
結果として、関数呼び出しのオーバーヘッドがなくなり、より高速なコードになります。
-->

---

## 5: 配列の型を固定する (Elements Kind)

**V8の気持ち（なぜ重要か？）**:
V8は、配列の要素の型に応じて内部的に最も効率的な表現（`Elements Kind`）を選択します。要素がすべて整数であれば非常に高速な整数の配列として扱いますが、途中で1つでも浮動小数点数やオブジェクトが混ざると、より汎用的で低速な表現に変換（遷移）せざるを得ません。この遷移はV8にとって大きな負担です。

<!--
最後の5つ目は、**配列の型を固定すること**です。
先ほど説明した `Elements Kind` を思い出してください。V8は、配列の中身に応じて最も効率的な表現を選んでくれます。その優しさを裏切ってはいけません。
-->

---

## ❌ Before: 配列の型が途中で変わる

最初は整数だけだった配列に、後から浮動小数点数を追加しています。この瞬間に `Elements Kind` のコストが高い遷移が発生します。

```javascript
const numbers = [1, 2, 3]; // PACKED_SMI_ELEMENTS (最速)

// この代入により、配列は PACKED_DOUBLE_ELEMENTS (低速) に変換される
numbers.push(4.5);

// さらにオブジェクトを追加すると PACKED_ELEMENTS (さらに低速) になる
numbers.push({});
```

<!--
このコードは、最初に最速の整数配列(`PACKED_SMI_ELEMENTS`)を作っておきながら、後から浮動小数点数やオブジェクトを追加しています。
そのたびに、V8の内部ではコストの高い配列の変換処理が発生してしまいます。
-->

---

## ✅ After: 配列の型が一貫している

配列の型を一貫させることで、`Elements Kind` の遷移を防ぎ、V8は最速の状態で処理を続けることができます。

```javascript
// 整数配列
const integers = [1, 2, 3];

// 浮動小数点数配列
const doubles = [1.1, 2.2, 3.3];

// オブジェクト配列
const objects = [{}, {}];
```

注意: `-0`、`NaN`、`Infinity` を 1 つでも含めると `…_DOUBLE_ELEMENTS` に遷移します。整数配列を維持したい場合は初期化時に値を正規化/バリデーションしましょう。

<!--
このように、最初から用途に応じて配列を分けましょう。
整数用の配列、浮動小数点数用の配列、オブジェクト用の配列。
こうすることで、`Elements Kind`の不要な遷移を防ぎ、V8はそれぞれの配列を最も効率的な方法で処理し続けることができます。
-->

---

## 「V8の気持ち」と私たちのコード

これまでのTIPSを、V8の内部動作と結びつけて整理してみましょう。

| V8の気持ち（内部動作） | 私たちが書くべきコード |
| :--- | :--- |
| **Inline Cache** を効かせたい | オブジェクトの**形状を一定に**保つ |
| **投機的最適化**を成功させたい | 変数や引数の**型を安定**させる |
| **脱最適化**を避けたい | **例外の発生を防ぐ**事前チェックを行う |
| **インライン化**しやすくしたい | **小さく単一責任の関数**に分割する |
| **Elements Kind**の遷移を防ぎたい| 配列に入れる**要素の型を固定**する |

<!--
これまでのTIPSを、「V8の気持ち」と結びつけて整理してみましょう。

- V8は **Inline Cache** を効かせたいと思っています。だから私たちは、**オブジェクトの形状を一定に**保ちます。
- V8は **投機的最適化** を成功させたいと思っています。だから私たちは、**変数の型を安定**させます。
- V8は **脱最適化** をしたくありません。だから私たちは、**例外の発生を防ぎ**ます。
- V8は関数を **インライン化** したいと思っています。だから私たちは、**関数を小さく**書きます。
- V8は **Elements Kind** の遷移をしたくありません。だから私たちは、**配列の要素の型を固定**します。

結局のところ、V8は「予測できること」が大好きなんです。
-->

---

## まとめ

V8は **Ignition, Sparkplug, Maglev, TurboFan** という多層コンパイラ構造で、起動速度と実行速度を両立させています。

開発者として重要なのは、V8の気持ち、すなわち **「予測しやすいコードを好む」** という性質を理解することです。

**オブジェクトの形状**や**配列の型**を安定させ、**関数の引数の型**を揃え、**例外に頼らない**安定した処理を心がけ、**関数を小さく保つ**こと。これらの積み重ねが、V8があなたのコードを最大限に高速化するための鍵となります。

<!--
本日のまとめです。
V8は、**Ignition, Sparkplug, Maglev, TurboFan** という多層コンパイラ構造で、起動速度と実行速度を両立させています。

そして、開発者として私たちが理解すべき最も重要な「V8の気持ち」とは、**「予測しやすいコードを好む」** ということです。

オブジェクトの形状や型を安定させ、例外に頼らず、関数を小さく保つ。
一つ一つは小さなことかもしれませんが、この積み重ねが、V8の能力を最大限に引き出し、アプリケーションのパフォーマンスを向上させるための鍵となります。
-->

---

## ご清聴ありがとうございました

本日のスライドは下記のリポジトリで公開しています。<br>
内容の修正・改善など、お気軽にPull Requestをお送りください。<br>
11/30の関西のフロントエンドカンファレンスでも登壇するので、そこでもお会いしましょう！

<https://github.com/riya-amemiya/amemiya_riya_slide_data/tree/main/frontend_conf_tokyo_2025>

- XやGitHubなど: <https://riya-amemiya-links.tokidux.com/>

<div class="flex justify-center">
<img src="/link.png" alt="リンク集" class="w-48 h-48" />
</div>

<hr>

<div class="text-sm">

このスライドは **CC BY-SA 4.0** でライセンスされています。<br>
**より自由な翻訳を可能にするため**、翻訳は例外的に **CC BY 4.0** での配布が許可されています。<br>
Required Attribution: Riya Amemiya (<https://github.com/riya-amemiya>)

</div>

<!--
これで私の発表を終わります。
本日のスライドはGitHubで公開していますので、ぜひご覧ください。Pull Requestもお待ちしております。
また、11月30日に関西で開催されるフロントエンドカンファレンスでも登壇しますので、そちらでもお会いできるのを楽しみにしています。

ご清聴いただき、誠にありがとうございました。
-->